###################### R-code to perform the simulation study #####################
library("tidyverse")
library("netmeta")
library("mvmeta")
library("gemtc")

### 1. Simulate a relevant data set: 
# 
# Using the R-code published in the supplement of:
# Seide, SE, Jensen, K, Kieser, M. Simulation and data-generation for 
# random-effects network meta-analysis of binary outcome. Statistics in Medicine.
# 2019; 38: 3288- 3303. https://doi.org/10.1002/sim.8193 
#


### 2. Functions to analyse the data set (applied to each network of trials)
# 
#### 2.a. Using netmeta
    analyseNetmeta <- function(data, n.arm = 100){
      
      # calculate the log-OR and its standard error
      data <- data %>%
        rowwise() %>%
        mutate(TE = log((x.arm2.DGMmf/(n.arm2 - x.arm2.DGMmf))/
                          (x.arm1.DGMmf/(n.arm1 - x.arm1.DGMmf))), 
               seTE = sqrt((1/x.arm2.DGMmf) + (1/x.arm1.DGMmf) + 
                             (1/(n.arm2 - x.arm2.DGMmf)) + (1/(n.arm1 - x.arm1.DGMmf)))) 
      
      # perform the network meta-analysis 
      netmeta.model <- netmeta(data = data, TE = TE, seTE = seTE, 
                               treat1 = treat1, treat2 = treat2, 
                               studlab = study.id, sm = "OR")
      
      return(netmeta.model)
    }

#### 2.b. Using mvmeta
    analyseMvmeta <- function(data){
      # calculate the log-OR and its standard error
      data <- data %>%
        rowwise() %>%
        mutate(TE = log((x.arm2.DGMmf/(n.arm2 - x.arm2.DGMmf))/
                          (x.arm1.DGMmf/(n.arm1 - x.arm1.DGMmf))), 
               seTE = (1/x.arm2.DGMmf) + (1/x.arm1.DGMmf) + 
                 (1/(n.arm2 - x.arm2.DGMmf)) + (1/(n.arm1 - x.arm1.DGMmf)), 
               contrast.id = paste("T", treat1, treat2, sep ="")) 
      
      # perform the meta-regression on the treatment contrasts (only one outcome)
      mvmeta.model <- mvmeta(formula = TE ~ -1 + contrast.id,
                             S = seTE, 
                             data = data, 
                             method = "reml")
      
      
      
      return(mvmeta.model)
    }
    
#### 2.c. Using gemtc with a U(0,4) prior on heterogeneity
    analyseMtcObject <- function(data){
      # prepare the data set for the long-format used in gemtc
      dat1 <- data %>%
        select(study.id, treat1, n.arm1, x.arm1.DGMmf) %>%
        rename("study" = "study.id", 
               "treatment" = "treat1", 
               "responders" = "x.arm1.DGMmf", 
               "sampleSize" = "n.arm1")
      
      dat2 <- data %>%
        select(study.id, treat2, n.arm2, x.arm2.DGMmf) %>%
        rename("study" = "study.id", 
               "treatment" = "treat2", 
               "responders" = "x.arm2.DGMmf", 
               "sampleSize" = "n.arm2")
      
      data <- rbind(dat1, dat2)
      data <- data %>%
        mutate(ID = paste(study, treatment, sep ="")) %>%
        filter(!duplicated(ID)) %>%
        select(-ID)
      
      # initialize the network
      mtc.network <- mtc.network(data.ab = data, description = "Network")
      
      # specify the estimation parameters 
      mtc.model1 <- mtc.model(mtc.network, type ="consistency", om.scale = 2,
                              hy.prior=mtc.hy.prior("std.dev", "dunif", 0, "om.scale"))
      mtc.model1$inits[[1]]$.RNG.name <- "base::Mersenne-Twister"
      mtc.model1$inits[[2]]$.RNG.name <- "base::Mersenne-Twister"
      mtc.model1$inits[[3]]$.RNG.name <- "base::Mersenne-Twister"
      mtc.model1$inits[[4]]$.RNG.name <- "base::Mersenne-Twister"
      
      mtc.model1$inits[[1]]$.RNG.seed <- 58982
      mtc.model1$inits[[2]]$.RNG.seed <- 58983
      mtc.model1$inits[[3]]$.RNG.seed <- 58984
      mtc.model1$inits[[4]]$.RNG.seed <- 58985
      mtc.run1 <- mtc.run(mtc.model1, thin = 10)

      return(mtc.run1)
      
    }
    
#### 2.d. Using gemtc with a hn(0.5) prior on heterogeneity
# use the same function as before, change within the function mtc.model for 
# different prior. (Give precision (1/0.5)^2 not variance for half-normal)
    mtc.model(mtc.network, type ="consistency", om.scale = 2,
              hy.prior=mtc.hy.prior("std.dev", "dhnorm", 0, 4)) 
    

#### 3. Extract all necessary values, e.g. mean, lower and upper bound of CI, 
####    summarize and plot (not included in the code snippet)   
    

